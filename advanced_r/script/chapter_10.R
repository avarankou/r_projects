# this file contains worked examples and solutions to the problems from Chapter 10 of
# Wickham, H. 2019. "Advanced R", Chapman and Hall.
# the text is available at
# https://adv-r.hadley.nz/function-factories.html

library(rlang)
library(ggplot2)
library(scales)

# function factories are functions that generate (produce) other functions
# the key feature is that the functions thus generated are in (and limited to) the environment from which the generator function is called


# factory fundamentals ----------------------------------------------------
# the below function is a simple function factory
power1 <- function(exp) {
  return(
    function(x) {
      return( x^exp )
    }
  )
}

square <- power1(exp = 2)
cube   <- power1(exp = 3)

# observe that the two newly generated functions have different environments and share the parent environment
env_print(square)
fn_env(square)$exp

env_print(cube)
fn_env(cube)$exp

# since exp argument is evaluated lazily, a function generated by power1() can be unintentionally modified
x <- 2
square_ <- power1(exp = x)
x <- 4
# exp is first evaluated after the first call of square_(); however, the arguments was not in place and the value has been modified since the binding of square_ to power(exp = x) has been created
# hence, 
square_(2) == 16 # TRUE

# to avoid this, remove the cause, which is lazy evaluation, by calling force() explicitly
power2 <- function(exp) {
  force(exp)
  return(
    function(x) {
      return( x^exp )
    }
  )
}

x <- 2
square_ <- power2(exp = x)
x <- 4
square_(2) == 4 # TRUE

# generated functions are bound to the environment from which they have been generated
# this allows creating stateful functions, i.e. functions that have access to the same variables over multiple invocations; these variables need not be in the global environment, which is trivial
# compare the following two functions
counter_generator <- function(init = 0) {
  count <- init
  mount <- init
  
  return( function(x) {
    count <- count + 1 # LHS count is created locally, even though RHS comes from the parent environment
    mount <<- mount + 1
    # note the super-assignment operator, `->>`; if mount is found un any of the parent environments, it is modified; otherwise, it is created in the global environment
    return( paste("(", count, ",", mount, ")") )
  })
}


counter <- counter_generator()
reduce(map(1:10, counter), paste)

# however, due to the binding to the enclosing environment, the temporary variables used in a function factory retain their bindings as well and the garbage collector cannot work efficiently
# the unnecessary bindings must be explicitly removed with a call to rm()
f1 <- function(n) {
  x <- runif(n) # x will not be removed by GC as long as there are some functions generated by f1
  m <- mean(x)
  function() m
}

g1 <- f1(1e6)
lobstr::obj_size(g1) # 8 MB

f2 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  rm(x) # as x is unbound, GC will clean it up
  function() m
}

g2 <- f2(1e6)
lobstr::obj_size(g2) # 2 KB


# exercises 10.2.6 --------------------------------------------------------

# 10.2.6.1
# although force(x) is equivalent to x it is better to use the former, since it makes the developer's  intention clear

# 10.2.6.2
# consider two function factories present in base R
# (i)  approxfun()
# (ii) ecdf()

# (i) approxfun() returns an instance of approx(), the latter computes a linear interpolation of given datapoints; base R points() and curve(), however, take either the points to be plotted or a function returning the points, so the convenience of approxfun() is not clear from the example

x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(y, col = "green", pch = "x")
points(approx(x, y), col = "blue", pch = "*")
points(approx(x, y, method = "constant"), col = "red", pch = "*")

f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
     col = "tomato", add = TRUE, lty = 3, lwd = 2)

# (ii) ecdf()
##-- Simple didactical  ecdf  example :
x <- rnorm(12)
Fn <- ecdf(x)
Fn     # a *function*
Fn(x)  # returns the percentiles for x
tt <- seq(-2, 2, by = 0.1)
12 * Fn(tt) # Fn is a 'simple' function {with values k/12}
summary(Fn)
##--> see below for graphics
knots(Fn)  # the unique data values {12 of them if there were no ties}

# 10.2.6.3
# pick() takes an index, i, as an argument and returns a function with an argument x that subsets x with i
# the description sounds twisted but is actually simple
pick <- function(i) {
  return(
    function(x) {
      return( x[[i]] )
    }
  )
}

x <- runif(10)
pick(1)(x) == x[[1]]

# however, writing a functional code, it is worthwhile using the pipe to imporve readability
every(map2(lapply(mtcars, pick(5)), lapply(mtcars, function(x) x[[5]]), ~ .x == .y), ~ .x)

lapply(mtcars, pick(5)) |>
  map2(lapply(mtcars, function(x) x[[5]]), ~ .x == .y) |> 
  every(~ .x)

# better still, get to know base R fundamentals
all.equal(lapply(mtcars, pick(5)), lapply(mtcars, function(x) x[[5]]))

# 10.2.6.4
central_moment_i <- function(i = 2) {
  return (
    function(x) {
      return ( sum((x - mean(x)) ^ i) / length(x) )
    }
  )
}

cm1 <- central_moment_i(1)
cm2 <- central_moment_i(2)
x <- runif(100)

all.equal(cm1(x), 0)
all.equal(cm2(x), var(x) * 99 / 100)

# 10.2.6.5
i <- 0
new_counter2 <- function(x) {
  i <<- i + 1
  i
}

# seq(1:10), so it is similar to counter_generator() above
reduce(map(1:10, new_counter2), c)

# however, another counter will resume counting from i. not to mention that i - being in the global environment - is accessible to all other functions
reduce(map(1:10, new_counter2), c)

# 10.2.6.6
# see counter_generator() above


# graphical factories -----------------------------------------------------
# first, consider scales::package, the primary interface of which is made of function factories, i.e. functions that return labelling functions; the latter are provided as arguments to ggplot2:: routines
vals <- runif(5, 1e5, 1e7)
scales::scientific_format()(vals)
scales::label_number(scale = 1e-3, suffix = "K")(vals)

df <- data.frame(
  x = 1:5,
  y = vals
)
core <- ggplot(df, aes(x, y)) +
  geom_point() +
  scale_x_continuous(breaks = 1, labels = NULL) +
  labs(x = NULL, y = NULL)

# compare plots with different labels
core

core + scale_y_continuous(
  labels = label_comma()
)

core + scale_y_continuous(
  labels = label_number(scale = 1e-3, suffix = "K")
)  

# another example is geom_histogram(), which takes binwidth as a function; this allows setting different binwidths for different facets of the same plot
sd <- c(1, 5, 15)
n <- 100

df <- data.frame(x = rnorm(3 * n , sd = sd), sd = rep(sd, n))

ggplot(df, aes(x)) +
  geom_histogram(binwidth = 2) +
  facet_wrap(~sd, scales = "free_x") +
  labs(x = NULL)

binwidth_bins <- function(n) {
  force(n)
  
  return(
    function(x) {
      return( (max(x) - min(x)) / n )
    })
}

ggplot(df, aes(x)) +
  geom_histogram(binwidth = binwidth_bins(20)) +
  facet_wrap(~sd, scales = "free_x")


# statistical factories ---------------------------------------------------
# first, consider a transformation function, viz. a Box-Cox transformation
boxcox <- function(lambda) {
  if (lambda == 0) {
    return ( function(x) { log(x) } )
  }
  else {
    return (
      function(x) { (x ^ lambda - 1) / lambda }
    )
  }
}

stat_boxcox <- function(lambda) {
  stat_function(aes(colour = lambda), fun = boxcox(lambda), linewidth = 1)
}

ggplot(data.frame(x = c(0, 5)), aes(x)) +
  lapply(c(0.5, 1, 1.5), stat_boxcox) +
  scale_colour_viridis_c(limits = c(0, 1.5))

ggplot(data.frame(x = c(0.01, 1)), aes(x)) +
  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) +
  scale_colour_viridis_c(limits = c(0, 1.5))

# second, consider bootstrap factories
# the factory generates a function which generates bootstrap samples on request
# the utility comes with supplying the bootstrap parameters only once and not for each call
boot_permute <- function(df, formula) {
  model <- lm(formula, df)
  fitted <- unname(fitted(model))
  resid <- unname(resid(model))
  
  rm(model) # model object is rather big, so remove it since it won't be removed by GC until the factory itself and all functions generated by it will be
  
  return( function() {
    fitted + sample(resid)
    })
}

boot <- boot_permute(mtcars, mpg ~ wt)
head(boot())
head(boot())

# thirdly, consider the maximum likelihood estimation, MLE
# in this example, we find the value of lambda of which maximises the probability of the observation coming from a Poisson distribution with the lambda as its (only) parameter
lprob_poisson <- function(x) {
  n <- length(x)
  s <- sum(x)
  s_l_f <- sum(lfactorial(x))
  
# note that the computations with x are performed in the factory's body and not in that of a generated function
  return( function(lambda) {
    log(lambda) * s - n * lambda - s_l_f
  })
}

obs <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)
optimise(lprob_poisson(obs), c(0, 100), maximum = TRUE)

# note, however, that in this case one can simply use optimise(), since the latter can forward arguments to its argument function
lprob_poisson_f <- function(lambda, x) {
  n <- length(x)
  return( (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x)) )
}

optimise(lprob_poisson_f, c(0, 100), x = obs, maximum = TRUE)


# exercises 10.4.4 --------------------------------------------------------
# 10.4.4.1
# as the first line of boot_model() body calls lm(...), the df and model arguments are evaluated; thus, it is not necessary to explicitly force their evaluation

# 10.4.4.2
# observe that in boxcox() above the function factory takes lambda as the only parameter while the generated functions take x; this implies the following use case: multiple vectors of observations are normalised by calling the same transformation function with some specific lambda, while there might be different groups of observations normalised with various generated functions (and thus different lambdas)
# if, on the contrary, the boxcox() implementation takes x as the parameter of function factory and leaves it to the generated functions to specify lambda, then completely different use case is intended; namely, that of performing multiple normalisations of the same vector of observations with different lambdas, e.g. in an optimisation function that tries to minimise the deviation from the normal distribution; if several gorups of observations are studied, a function factory will be called for each of them

# 10.4.4.3
# as the copied data is not modified inside the function generated by boot_permute() or in the environment which originally stores the data, the data is not going to be copied

# 10.4.4.4
# presumably, calling optimise() with the function factory is faster, since in this case some costly pre-computations are performed only once; by the same token, the difference will increase as the vector's size does
# quick benchmarking confirms this supposition
obs <- rpois(1000, lambda = 10)

lb_ff <- bench::mark(
  optimise(lprob_poisson(obs), c(0, 100), maximum = TRUE)
)


lb_f <- bench::mark(
  optimise(lprob_poisson_f, c(0, 100), x = obs, maximum = TRUE)
)

cmp = rbind(lb_ff, lb_f)
rownames(cmp) <- c("function factory", "function")
cmp

# function factories + functionals -----------------------------------------
# exercises 10.5.1 --------------------------------------------------------

# 10.5.1.1
# it depends on the type of x and on whether f and z existing in the calling environment or not
# the call that makes more sense, however, is f(x$z) or x$f(x$z), if x is a list with a function f as an node

# 10.5.1.2
# generally, it is better not to overwrite widely-used functions of base R or external libraries
# TODO
