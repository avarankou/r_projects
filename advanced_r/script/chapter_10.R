# this file contains worked examples and solutions to the problems from Chapter 10 of
# Wickham, H. 2019. "Advanced R", Chapman and Hall.
# the text is available at
# https://adv-r.hadley.nz/function-factories.html

library(rlang)
library(ggplot2)
library(scales)

# function factories are functions that generate (produce) other functions
# the key feature is that the functions thus generated are in (and limited to) the environment from which the generator function is called


# factory fundamentals ----------------------------------------------------
# the below function is a simple function factory
power1 <- function(exp) {
  return(
    function(x) {
      return( x^exp )
    }
  )
}

square <- power1(exp = 2)
cube   <- power1(exp = 3)

# observe that the two newly generated functions have different environments and share the parent environment
env_print(square)
fn_env(square)$exp

env_print(cube)
fn_env(cube)$exp

# since exp argument is evaluated lazily, a function generated by power1() can be unintentionally modified
x <- 2
square_ <- power1(exp = x)
x <- 4
# exp is first evaluated after the first call of square_(); however, the arguments was not in place and the value has been modified since the binding of square_ to power(exp = x) has been created
# hence, 
square_(2) == 16 # TRUE

# to avoid this, remove the cause, which is lazy evaluation, by calling force() explicitly
power2 <- function(exp) {
  force(exp)
  return(
    function(x) {
      return( x^exp )
    }
  )
}

x <- 2
square_ <- power2(exp = x)
x <- 4
square_(2) == 4 # TRUE

# generated functions are bound to the environment from which they have been generated
# this allows creating stateful functions, i.e. functions that have access to the same variables over multiple invocations; these variables need not be in the global environment, which is trivial
# compare the following two functions
counter_generator <- function(init = 0) {
  count <- init
  mount <- init
  
  return( function(x) {
    count <- count + 1 # LHS count is created locally, even though RHS comes from the parent environment
    mount <<- mount + 1
    # note the super-assignment operator, `->>`; if mount is found un any of the parent environments, it is modified; otherwise, it is created in the global environment
    return( paste("(", count, ",", mount, ")") )
  })
}


counter <- counter_generator()
reduce(map(1:10, counter), paste)

# however, due to the binding to the enclosing environment, the temporary variables used in a function factory retain their bindings as well and the garbage collector cannot work efficiently
# the unnecessary bindings must be explicitly removed with a call to rm()
f1 <- function(n) {
  x <- runif(n) # x will not be removed by GC as long as there are some functions generated by f1
  m <- mean(x)
  function() m
}

g1 <- f1(1e6)
lobstr::obj_size(g1) # 8 MB

f2 <- function(n) {
  x <- runif(n)
  m <- mean(x)
  rm(x) # as x is unbound, GC will clean it up
  function() m
}

g2 <- f2(1e6)
lobstr::obj_size(g2) # 2 KB


# exercises 10.2.6 --------------------------------------------------------

# 10.2.6.1
# although force(x) is equivalent to x it is better to use the former, since it makes the developer's  intention clear

# 10.2.6.2
# consider two function factories present in base R
# (i)  approxfun()
# (ii) ecdf()

# (i) approxfun() returns an instance of approx(), the latter computes a linear interpolation of given datapoints; base R points() and curve(), however, take either the points to be plotted or a function returning the points, so the convenience of approxfun() is not clear from the example

x <- 1:10
y <- rnorm(10)
par(mfrow = c(2,1))
plot(x, y, main = "approx(.) and approxfun(.)")
points(y, col = "green", pch = "x")
points(approx(x, y), col = "blue", pch = "*")
points(approx(x, y, method = "constant"), col = "red", pch = "*")

f <- approxfun(x, y)
curve(f(x), 0, 11, col = "green2")
points(x, y)
is.function(fc <- approxfun(x, y, method = "const")) # TRUE
curve(fc(x), 0, 10, col = "darkblue", add = TRUE)
## different extrapolation on left and right side :
plot(approxfun(x, y, rule = 2:1), 0, 11,
     col = "tomato", add = TRUE, lty = 3, lwd = 2)

# (ii) ecdf()
##-- Simple didactical  ecdf  example :
x <- rnorm(12)
Fn <- ecdf(x)
Fn     # a *function*
Fn(x)  # returns the percentiles for x
tt <- seq(-2, 2, by = 0.1)
12 * Fn(tt) # Fn is a 'simple' function {with values k/12}
summary(Fn)
##--> see below for graphics
knots(Fn)  # the unique data values {12 of them if there were no ties}

# 10.2.6.3
# pick() takes an index, i, as an argument and returns a function with an argument x that subsets x with i
# the description sounds twisted but is actually simple
pick <- function(i) {
  return(
    function(x) {
      return( x[[i]] )
    }
  )
}

x <- runif(10)
pick(1)(x) == x[[1]]

# however, writing a functional code, it is worthwhile using the pipe to imporve readability
every(map2(lapply(mtcars, pick(5)), lapply(mtcars, function(x) x[[5]]), ~ .x == .y), ~ .x)

lapply(mtcars, pick(5)) |>
  map2(lapply(mtcars, function(x) x[[5]]), ~ .x == .y) |> 
  every(~ .x)

# better still, get to know base R fundamentals
all.equal(lapply(mtcars, pick(5)), lapply(mtcars, function(x) x[[5]]))

# 10.2.6.4
central_moment_i <- function(i = 2) {
  return (
    function(x) {
      return ( sum((x - mean(x)) ^ i) / length(x) )
    }
  )
}

cm1 <- central_moment_i(1)
cm2 <- central_moment_i(2)
x <- runif(100)

all.equal(cm1(x), 0)
all.equal(cm2(x), var(x) * 99 / 100)

# 10.2.6.5
i <- 0
new_counter2 <- function(x) {
  i <<- i + 1
  i
}

# seq(1:10), so it is similar to counter_generator() above
reduce(map(1:10, new_counter2), c)

# however, another counter will resume counting from i. not to mention that i - being in the global environment - is accessible to all other functions
reduce(map(1:10, new_counter2), c)

# 10.2.6.6
# see counter_generator() above


# graphical factories -----------------------------------------------------
# TODO


# statistical factories ---------------------------------------------------
# TODO


# function factories + functionals -----------------------------------------
# TODO
